<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Shout out to http://www.marcofolio.net/webdesign/build_native-looking_apps_for_ios.html -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="white" />
  <meta name="description" content="MeshCore Coverage - Personal Coverage Map">
  <meta name="keywords" content="MeshCore,coverage,cascadia,pugetmesh">
  <meta name="author" content="Kyle Reed">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" href="content/icon.png" />
  <link rel="icon" href="content/icon.png" />
  <link rel="stylesheet" type="text/css" href="content/style.css" />

  <title>MeshCore Coverage</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

  <!-- MarkerCluster (optional, can be toggled) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <style>
    html,
    body,
    #map {
      height: 100%;
      margin: 0;
    }

    #map {
      position: absolute;
      inset: 0;
    }

    .toolbar {
      position: absolute;
      top: .75rem;
      left: .75rem;
      z-index: 1000;
      background: rgba(255, 255, 255, .95);
      backdrop-filter: blur(2px);
      border: 1px solid #ddd;
      border-radius: .75rem;
      padding: .75rem;
      max-width: 480px;
      font: 14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif;
      box-shadow: 0 6px 24px rgba(0, 0, 0, .12);
    }

    .toolbar label {
      display: block;
      font-weight: 600;
      margin-bottom: .25rem;
    }

    .toolbar input[type="text"] {
      width: 100%;
      box-sizing: border-box;
      padding: .5rem .6rem;
      border-radius: .5rem;
      border: 1px solid #ccc;
    }

    .toolbar .row {
      display: flex;
      gap: .5rem;
      align-items: center;
      flex-wrap: wrap;
      margin-top: .5rem;
    }

    .toolbar button {
      padding: .5rem .8rem;
      border: 1px solid #bbb;
      border-radius: .5rem;
      cursor: pointer;
      background: #fff;
    }

    .toolbar .pill {
      display: inline-flex;
      align-items: center;
      gap: .4rem;
      padding: .35rem .6rem;
      border: 1px solid #bbb;
      border-radius: 999px;
      background: #fff;
    }

    .toolbar .status {
      margin-top: .5rem;
      color: #444;
    }

    .leaflet-popup-content {
      font: 13px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    .attribution-tweak .leaflet-control-attribution {
      font-size: 11px;
    }
  </style>
</head>

<body class="attribution-tweak">
  <div id="map"></div>

  <div class="toolbar">
    <label for="endpoint">JSON endpoint</label>
    <input id="endpoint" type="text" value="https://mesh-map.pages.dev/getdata" />
    <div class="row">
      <button id="btnLoad">Fetch & Plot</button>
      <span class="pill"><input id="chkCluster" type="checkbox" checked /> <span>Cluster</span></span>
      <span class="pill"><input id="chkPath" type="checkbox" /> <span>Draw path (array order)</span></span>
      <span class="pill"><input id="chkEdges" type="checkbox" checked /> <span>Draw edges (by id)</span></span>
      <span class="pill"><input id="chkFit" type="checkbox" checked /> <span>Auto-fit view</span></span>
    </div>
    <div class="status" id="status">Awaiting URL…</div>
    <details style="margin-top:.5rem">
      <summary>Expected JSON shape</summary>
      <pre style="white-space:pre-wrap; margin: .35rem 0 0 0;">Either an array of points <em>or</em> an object with <code>samples</code>, <code>repeaters</code>, and optional <code>edges</code>:

// Array form
[
  { "id":"A1", "lat": 47.6062, "lon": -122.3321, "name":"Point A" }
]

// Graph form
{
  "samples": [ { "id": 1, "lat": 47.7157, "lon": -122.0886 } ],
  "repeaters": [
    { "id": 2, "pre": "7e", "name": "WW7STR/PugetMesh Cougar", "lat": 47.54396, "lon": -122.10861 },
    { "id": 3, "pre": "2b", "name": "Devils Lake Repeater", "lat": 47.80334, "lon": -122.04273 }
  ],
  "edges": ["1,2", "3,2"]
}
</pre>
      <small>Keys accepted for coordinates: <code>lat/lng</code>, <code>lat/lon</code>, or
        <code>latitude/longitude</code>. Graph form draws edges by matching IDs in the <code>edges</code> list.</small>
    </details>
  </div>
  <div class="status" id="status">Awaiting URL…</div>
  <details style="margin-top:.5rem">
    <summary>Expected JSON shape</summary>
    <pre style="white-space:pre-wrap; margin: .35rem 0 0 0;">[
  { "id": "A1", "lat": 47.6062, "lon": -122.3321, "name": "Point A", "desc": "Optional description" },
  { "lat": 47.62, "lng": -122.3 },
  { "latitude": 47.59, "longitude": -122.35, "meta": { "elev": 103 } }
]</pre>
    <small>Keys accepted for coordinates: <code>lat/lng</code>, <code>lat/lon</code>, or
      <code>latitude/longitude</code>.</small>
  </details>
  </div>

  <script>
    // --- Map init -----------------------------------------------------------
    const map = L.map('map', { worldCopyJump: true }).setView([47.6062, -122.3321], 12);

    const otm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '© OpenStreetMap contributors'
    }).addTo(map);

    // Containers we replace on each load
    let pointsLayer = L.layerGroup().addTo(map);      // markers when not clustering
    let clusterLayer = L.markerClusterGroup({ showCoverageOnHover: false, spiderfyOnMaxZoom: true });
    let pathLayer = L.polyline([], { weight: 3, opacity: 0.8 }).addTo(map);
    let edgesLayer = L.layerGroup().addTo(map);       // polylines for edges

    const $ = (sel) => document.querySelector(sel);
    const endpointInput = $('#endpoint');
    const statusEl = $('#status');

    function setStatus(msg, isError = false) {
      statusEl.textContent = msg;
      statusEl.style.color = isError ? '#a00' : '#444';
    }

    function toNumber(x) {
      const n = typeof x === 'string' ? x.trim() : x;
      return (n === '' || n === null || n === undefined) ? NaN : Number(n);
    }

    function normalizePoint(p) {
      const lat = toNumber(p.lat ?? p.latitude);
      const lng = toNumber(p.lng ?? p.lon ?? p.longitude);
      if (Number.isFinite(lat) && Number.isFinite(lng)) return { lat, lng, raw: p };
      return null;
    }

    async function fetchPoints(url) {
      setStatus('Fetching…');
      const t0 = performance.now();
      const resp = await fetch(url, { headers: { 'Accept': 'application/json' } });
      if (!resp.ok) throw new Error(`HTTP ${resp.status} ${resp.statusText}`);
      const data = await resp.json();
      const elapsed = (performance.now() - t0).toFixed(0);
      setStatus(`Fetched in ${elapsed} ms. Rendering…`);
      return data;
    }

    // Parse the user's graph-shaped object into a flat point list and an id->latlng index
    function parseGraph(data) {
      const idToLatLng = new Map();
      const all = []; // {lat,lng,id,type,raw}

      function addList(arr, type) {
        (arr || []).forEach((item, idx) => {
          const np = normalizePoint(item);
          if (!np) return;
          const id = (item.id ?? item.name ?? `${type}_${idx}`) + '';
          const name = item.name ?? id;
          const heard = item.heard ?? null;
          const rec = { ...np, id, type, name, heard, raw: item };
          all.push(rec);
          idToLatLng.set(id, [np.lat, np.lng]);
        });
      }

      addList(data.samples, 'sample');
      addList(data.repeaters, 'repeater');

      const edges = (data.edges || []).map(e => String(e));
      return { points: all, idToLatLng, edges };
    }

    function styleFor(rec) {
      if (rec.type === 'repeater') {
        return { radius: 7, color: '#0a66c2', weight: 2, fillOpacity: 0.9 };  // repeater = blueish
      } else if (rec.type === 'sample') {
        if (rec.heard !== null) {
          return { radius: 6, color: '#07ac07', weight: 1, fillOpacity: 0.9 };  // sample, heard = greenish
        } else {
          return { radius: 6, color: '#e96767', weight: 1, fillOpacity: 0.9 };  // sample, unheard = reddish
        }
      } else {
        return { radius: 5, color: '#666', weight: 1, fillOpacity: 0.8 };    // unknown = gray
      }
    }

    function markerFor(rec) {
      const style = styleFor(rec);
      const m = L.circleMarker([rec.lat, rec.lng], style);
      const details = [
        `<strong>${escapeHtml(rec.name ?? rec.id)}</strong>`,
        `Lat: ${rec.lat.toFixed(6)}, Lng: ${rec.lng.toFixed(6)}`,
        rec.type ? `Type: ${rec.type}` : '',
        rec.raw && rec.raw.pre ? `Prefix: ${escapeHtml(rec.raw.pre)}` : ''
      ].filter(Boolean).join('<br/>');
      m.bindPopup(details, { maxWidth: 320 });
      return m;
    }

    function renderArray(list) {
      // Clear old
      pointsLayer.remove(); pointsLayer = L.layerGroup().addTo(map);
      clusterLayer.remove(); clusterLayer = L.markerClusterGroup({ showCoverageOnHover: false, spiderfyOnMaxZoom: true });
      pathLayer.setLatLngs([]);
      edgesLayer.clearLayers();

      const useCluster = $('#chkCluster').checked;
      const usePath = $('#chkPath').checked;
      const autoFit = $('#chkFit').checked;

      const bounds = [];
      const line = [];

      (list || []).forEach((item, idx) => {
        const np = normalizePoint(item);
        if (!np) return;
        const { lat, lng } = np;
        bounds.push([lat, lng]);
        line.push([lat, lng]);

        const title = item.name || item.id || `Point ${idx + 1}`;
        const details = [
          `<strong>${escapeHtml(title)}</strong>`,
          `Lat: ${lat.toFixed(6)}, Lng: ${lng.toFixed(6)}`,
          item.desc ? String(item.desc) : ''
        ].filter(Boolean).join('<br/>');

        const marker = L.marker([lat, lng]).bindPopup(details, { maxWidth: 320 });
        if (useCluster) clusterLayer.addLayer(marker); else pointsLayer.addLayer(marker);
      });

      if (useCluster) clusterLayer.addTo(map);
      if (usePath && line.length > 1) pathLayer.setLatLngs(line).bringToFront();
      if (autoFit && bounds.length) {
        if (bounds.length === 1) map.setView(bounds[0], 14); else map.fitBounds(bounds, { padding: [24, 24] });
      }
      setStatus(`Plotted ${bounds.length} valid point(s). ${list.length - bounds.length} skipped due to bad/missing coords.`);
    }

    function renderGraph(graph) {
      // Clear old
      pointsLayer.remove(); pointsLayer = L.layerGroup().addTo(map);
      clusterLayer.remove(); clusterLayer = L.markerClusterGroup({ showCoverageOnHover: false, spiderfyOnMaxZoom: true });
      pathLayer.setLatLngs([]);
      edgesLayer.clearLayers();

      const useCluster = $('#chkCluster').checked;
      const drawEdges = $('#chkEdges').checked;
      const autoFit = $('#chkFit').checked;

      const bounds = [];

      // Markers
      graph.points.forEach(rec => {
        const marker = markerFor(rec);
        bounds.push([rec.lat, rec.lng]);
        if (useCluster) clusterLayer.addLayer(marker); else pointsLayer.addLayer(marker);
      });
      if (useCluster) clusterLayer.addTo(map);

      // Edges
      if (drawEdges) {
        let ok = 0, miss = 0;
        graph.edges.forEach(pair => {
          const [a, b] = pair.split(',').map(s => s.trim());
          const A = graph.idToLatLng.get(a), B = graph.idToLatLng.get(b);
          if (A && B) {
            L.polyline([A, B], { weight: 2, opacity: 0.8, dashArray: '4,6' }).addTo(edgesLayer);
            ok++;
          } else {
            miss++;
          }
        });
        if (ok > 0) edgesLayer.bringToFront();
        setStatus(`Plotted ${graph.points.length} points. Drew ${ok} edge(s)${miss ? `, ${miss} missing id(s)` : ''}.`);
      } else {
        setStatus(`Plotted ${graph.points.length} points.`);
      }

      if (autoFit && bounds.length) {
        if (bounds.length === 1) map.setView(bounds[0], 14); else map.fitBounds(bounds, { padding: [24, 24] });
      }
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;');
    }

    async function loadFromEndpoint() {
      const url = (endpointInput.value || '').trim();
      if (!url) { setStatus('Please enter your JSON endpoint URL.', true); return; }
      try {
        const data = await fetchPoints(url);
        if (Array.isArray(data)) {
          renderArray(data);
        } else if (data && typeof data === 'object') {
          renderGraph(parseGraph(data));
        } else {
          throw new Error('Expected an array or an object with samples/repeaters.');
        }
      } catch (err) {
        console.error(err);
        setStatus(`Error: ${err.message}. (Check CORS on your microservice.)`, true);
      }
    }

    // Demo: You can paste a JSON array or object directly for quick testing
    async function loadInlineJsonIfPasted(e) {
      try {
        const txt = (endpointInput.value || '').trim();
        if (txt.startsWith('[') || txt.startsWith('{')) {
          const obj = JSON.parse(txt);
          if (Array.isArray(obj)) renderArray(obj); else renderGraph(parseGraph(obj));
        }
      } catch (_) { }
    }

    // Wire up UI
    document.getElementById('btnLoad').addEventListener('click', loadFromEndpoint);
    endpointInput.addEventListener('input', loadInlineJsonIfPasted);

    // Optional: try to load from ?endpoint= URL param
    const q = new URLSearchParams(location.search);
    if (q.has('endpoint')) {
      endpointInput.value = q.get('endpoint');
      loadFromEndpoint();
    }
  </script>
</body>

</html>
